---
title: "Second-Generation p-value Adaptive Monitoring Study Design Using The sgpvAM Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Second-Generation p-value Adaptive Monitoring Study Design using the sgpvAM package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=5) 
```

# sgpvAM package

The sgpvAM package allows the user to obtain study design operating characteristics under a variety of settings for adaptive monitoring using the second generation p-value.  

**MCMC Replicates:** The user may use the sgpvAM function to generate mcmc replicates of outcomes and intervention assignments along with an estimate of the effect and a lower- and upper- interval bound; replicates are generated using parallel computing.  Alternatively, the user may provide their own generated data together with an estimated effect and interval bounds.  When using the sgpvAM function, the user specifies the data generation function (any of the r[dist] such as rnorm) along with arguments to the function.  Similarly, the user specifies effect generation which may be fixed or random.  At this point, operating characteristics are investigated for fixed effects.  However, by specifing a distribution for the effects, the user may explore False Discovery Probabilities and other operating characterstics dependent on distributional assumptions of the effect.

**One- vs Two-Sided Hypotheses:** Clinical Guideposts defining regions of Trivial and Highly Actionable Effects must be provided though may be one- or two-sided.  The point null must be within the Trivial Region and cannot be a boundary of the region.  For general nomenclature, inputs to define the regions are: deltaL2 (the Clinically Highly Actionable Boundary less than the point null), deltaL1 (the Trivial Region Boundary less than the point null), deltaG1 (the Trivial Region Boundary greater than the point null), and deltaG2 (the Clinically Highly Actionable Boundary greater than the point null).

**Tuning study parameters:** To maximize performance of operating characteristics under a given sample size, the sgpvAM function allows the user to specifiy multiple wait time settings, frequency of looks, and number of steps before affirming a stopping rule.  (The wait time is the time until the expected Confidence Interval Width achieves a certain length or less).

**Wait time until monitoring:** Current recommendations for wait time are based upon the minimum sample size to achieve an expected minimum Margin of Error (half width of an interval) of the treatment effect.  In extensive simulations of one- and two-sided studies, the Type I Error is optimally reduced by waiting until the Margin of Error has a width equal to the distance between the point null and the midpoint between the nearest boundaries defining the Trivial and Highly Actionable Region.  While optimal for reducing the Type I Error, there are two draw backs: 1) the true standard deviation may not be known and 2) extreme effects are followed for a minimum sample size which may be much longer than needed to stop the trial early.

The following rule is still under developmental.  The wait time is a continuous function across the range of treatment effects.  It adds to the wait Time input flexibility for the study to stop earlier by having a larger margin of error.

* waitTime is input into function of initial wait time for minimal margin of error.

* addTime <- abs(est - midpoint) / 6

* waitMargin of error <- waitTime + addTime

* require at least 30 patients

* adaptively monitor for when the margin of error is less than the required margin of error.  Require an affirmation step for starting to monitor.

Because the estimated effect and variability are still converging to their true value, both are less than expected one half of the time.  As a consequence, the study may begin monitoring early and increase the risk of making a false discovery.  For this reason, we require the affirmation step to begin monitoring.



**Operating characteristics under normal outcomes:** After generating the operating characterstics under a fixed normal outcome, the user may use the locationShift function to obtain operating characterstics under a range of fixed treatment effects.  The function uses the saved mcmc replicates and adds to them if needed for additional monitoring.

**ECDF of sample size and bias:** Once a study design has been selected based on average performance (sample size, bias, and error probabilities), the user may use the ecdf.sgpv function to see the empirical cumulative distribution for sample size and bias under a specific design.  The user may see the estimated probability of the sample size exceeding a certain maximum sample size.

**Operating System:** The package has been developed on a MAC system and has been run on both MAC and the ACCRE cluster.  Please contact the author if issues arrise running on parallel with other operating systems.

**General suggestions:** Computations may be time consuming.  It is recommended to start with 1000 replicates to get a general sense of average sample size and error probabilities under a variety of investigated wait times and affirmation steps.  Investigating many wait times increases the computational burden.  It is also recommended to generate mcmc replicates in the (or one of the) mid point(s) between the Clinically Trivial and Highly Actionable Regions.  This is the region with greatest expected sample size and reduces the burden of the locationShift function to generate more data.


# Required install of sgpv package

The sgpvAM package requires the sgpv package, which is currently available on github.  If this has not yet been installed, call:  

devtools::install_github("weltybiostat/sgpv")

# Github install of sgpvAM

devtools::install_github("chipmanj/sgpvAM")


# Example 1: A one-sided hypothesis with standard normal data

Suppose a study has a standard normal continuous outcome with a one-sided hypothesis where At Most Trivial Effects are defined as ($-\infty$, 0.2] and Highly Actionable Effects are defined as [0.5, $\infty$).  Practically, we are limited to collecting at most 250 observations, yet outcomes are not observed immediately.  There is a lag time such that at the end of enrollment the study will have observed 200 observations (with 50 yet to be observed).  The study has potential to receive additional funding, so we are also interested to see the operating characteristics with an unrestricted in sample size.  We are still determining the best Margin of Error (half width of Confidence Interval) wait time and number of affirmation steps, so we will investigate wait times for the exptected Margin of Error to be between 0.2 and 0.35.  Enrollment and outcomes roughly occur in batches of 10 patients at a time, hence we will monitor the study at every tenth patient.  

We’ll use the sgpvAM package, making use of parallel clustering (which on this machine is 8 cores) and start with only 2000 replicates to explore operating characteristics for different Margin of Error wait times and different number of steps before affirming a rule to stop.  Using the sgpvAM the following call is made.



```{r}
# devtools::install_github("chipmanj/sgpvAM")
library(sgpvAM)

system.time(am <-  sgpvAM(nreps            = 2000,
                          maxAlertSteps    = 100,       
                          lookSteps        = 10,  
                          waitEmpirical    = TRUE,
                          minWaitN         = 30,
                          kSteps           = 10,
                          # waitWidths       = seq(0.0625, 0.7, by = 0.0125),
                          waitWidths       = seq(0.2, 0.35, length.out=5),
                          dataGeneration   = rnorm,   dataGenArgs = list(n=200),
                          effectGeneration = 0,
                          modelFit         = lmCI,
                          pointNull = 0, deltaL2 = NA, deltaL1=NA, deltaG1=0.2, deltaG2=0.5,
                          monitoringIntervalLevel = 0.05,
                          printProgress = TRUE,
                          maxN = 200, lagOutcomeN = 50, 
                          cores = detectCores()))

system.time(amShifted <- locationShift(am, shiftedThetas = seq(-0.5, 1, by = 0.05)))



# Unrestricted Sample Size
# Explore wait width (first with alert k specified at 50)
plot(amShifted, "n",                 alertK = 20,      xlim=c(-0.5, 1),   ylim=c(0,500))
plot(amShifted, "rejPN",             alertK = 20,      xlim=c(-0.5, 1),   ylim=c(0,1))
abline(h=0.05)
plot(amShifted, "bias",              alertK = 50,      xlim=c(-0.5, 1),   ylim=c(-0.05,0.05))
plot(amShifted, "mse",               alertK = 20,      xlim=c(-0.5, 1),   ylim=c(0,0.2))
plot(amShifted, "cover",             alertK = 20,      xlim=c(-0.5, 1),   ylim=c(0.85,1))
plot(amShifted, "stopNotImpactful",  alertK = 20,      xlim=c(-0.5, 1),   ylim=c(0,1))
plot(amShifted, "stopNotTrivial",    alertK = 20,      xlim=c(-0.5, 1),   ylim=c(0,1))

# Explore number of steps in affirmation step
plot(amShifted, "n",                 waitWidth = 0.275, alertK = c(0,20,50,100), xlim=c(-0.5, 1), ylim=c(0,500))
plot(amShifted, "bias",              waitWidth = 0.275, alertK = c(0,20,50,100), xlim=c(-0.5, 1), ylim=c(-0.10,0.10))
plot(amShifted, "mse",               waitWidth = 0.275, alertK = c(0,20,50,100), xlim=c(-0.5, 1), ylim=c(0,0.10))
plot(amShifted, "cover",             waitWidth = 0.275, alertK = c(0,20,50,100), xlim=c(-0.5, 1), ylim=c(0.85,1))
plot(amShifted, "stopNotImpactful",  waitWidth = 0.275, alertK = c(0,20,50,100), xlim=c(-0.5, 1), ylim=c(0,1))
plot(amShifted, "stopNotTrivial",    waitWidth = 0.275, alertK = c(0,20,50,100), xlim=c(-0.5, 1), ylim=c(0,1))


# Unrestricted Sample Size with lag of remaining outcomes
plot(amShifted, "n",                 alertK = 20,     xlim=c(-0.5,1),   ylim=c(0,500), sizeRestrictions = "lag")
plot(amShifted, "stopInconclusive",  alertK = 20,     xlim=c(-0.5,1),   ylim=c(0,0.5),   sizeRestrictions = "lag")
plot(amShifted, "stopInconclusive",  waitWidth = 0.275, alertK = c(0, 20, 50, 80), xlim=c(-0.5,1), ylim=c(0,0.5),   sizeRestrictions = "lag")

# Max N with immediate outcomes
plot(amShifted, "n",                 alertK = 20,     xlim=c(-0.5,1),   ylim=c(0,250), sizeRestrictions = "maxN")
plot(amShifted, "stopInconclusive",  alertK = 20,     xlim=c(-0.5,1),   ylim=c(0,1),   sizeRestrictions = "maxN")


summary(amShifted, alertK = 50, waitTime = 0.275, treatEffect = 0)
# summary(amShifted)
# summary(am)

```




# Example 2: A two-sided hypothesis with normal data

Suppose a study has a normal continuous outcome with standard deviation equal to two.  This study finds it beneficial to study both hypotheses of benefit and harm.  Clinically Trivial Effects are defined as [-0.4, 0.4] and clinically Highly Actionable effects are defined as ($-\infty$, -1] and [1, $\infty$).  Enrolling and observing outcomes is inexpensive but not immediate.  100 patients will still be followed-up by the end of enrollment.  We want to estimate the probability of finishing the study after observing 250 observations when the treatment effect is truly null.  We are still determining the best wait time and number of affirmation steps, so we will investigate wait times of Margin of Errors between 0.4 and 0.7.

We’ll use the sgpvAM package, making use of parallel clustering (which on this machine is 8 cores) and start with only 2000 replicates to explore operating characteristics for different Margin of Error wait times and different number of steps before affirming a rule to stop.  Using the sgpvAM the following call is made.


```{r, eval=FALSE}
system.time(am2 <-  sgpvAM(nreps            = 2000,
                           maxAlertSteps    = 100,       
                           lookSteps        = 1, 
                           waitEmpirical    = TRUE,
                           minWaitN         = 30,
                           kSteps           = 10, 
                           waitWidths       = seq(0.4,0.7,length.out=5),
                           dataGeneration   = rnorm,   dataGenArgs = list(n=200, sd=2),
                           effectGeneration = 0,
                           modelFit         = lmCI,
                           pointNull = 0, deltaL2 = -1, deltaL1=-0.2, deltaG1=0.2, deltaG2=1,
                           monitoringIntervalLevel = 0.05,
                           lagOutcomeN = 100,
                           cores=detectCores()))

system.time(amShifted2 <- locationShift(am2, shiftedThetas = seq(-2,2,by=0.25)))



# Unrestricted Sample Size
# Explore wait width (first with alert k specified at 50)
plot(amShifted2, "n",                 alertK = 50,      xlim=c(-2,2),   ylim=c(0,500))
plot(amShifted2, "rejPN",             alertK = 50,      xlim=c(-2,2),   ylim=c(0,1))
abline(h=0.05)
plot(amShifted2, "bias",              alertK = 50,      xlim=c(-2,2),   ylim=c(-0.15,0.15))
plot(amShifted2, "mse",               alertK = 50,      xlim=c(-2,2),   ylim=c(0,0.15))
plot(amShifted2, "cover",             alertK = 50,      xlim=c(-2,2),   ylim=c(0.85,1))
plot(amShifted2, "stopNotImpactful",  alertK = 50,      xlim=c(-2,2),   ylim=c(0,1))
plot(amShifted2, "stopNotTrivial",    alertK = 50,      xlim=c(-2,2),   ylim=c(0,1))

# Explore number of steps in affirmation s
plot(amShifted2, "n",                waitWidth = 0.7,  alertK = c(0, 20, 50, 100), xlim=c(-2,2),   ylim=c(0,500))
plot(amShifted2, "bias",             waitWidth = 0.7,  alertK = c(0, 20, 50, 100), xlim=c(-2,2),   ylim=c(-0.15,0.15))
plot(amShifted2, "mse",              waitWidth = 0.7,  alertK = c(0, 20, 50, 100), xlim=c(-2,2),   ylim=c(0,0.20))
plot(amShifted2, "cover",            waitWidth = 0.7,  alertK = c(0, 20, 50, 100), xlim=c(-2,2),   ylim=c(0.9,1))
plot(amShifted2, "stopNotImpactful", waitWidth = 0.7,  alertK = c(0, 20, 50, 100), xlim=c(-2,2),   ylim=c(0,1))  
plot(amShifted2, "stopNotTrivial",   waitWidth = 0.7,  alertK = c(0, 20, 50, 100), xlim=c(-2,2),   ylim=c(0,1))


# Unrestricted Sample Size with lag of remaining outcomes
plot(amShifted2, "stopInconclusive",  alertK = 50,     xlim=c(-2,2),   ylim=c(0,0.4),  sizeRestrictions = "lag")
plot(amShifted2, "stopInconclusive",  waitWidth = 0.55, alertK = c(0, 20, 50, 90), xlim=c(-2,2),   ylim=c(0,.4),  sizeRestrictions = "lag")
plot(amShifted2, "stopInconclusive",  waitWidth = 0.7, alertK = c(0, 20, 50, 90), xlim=c(-2,2),   ylim=c(0,.4),  sizeRestrictions = "lag")


summary(amShifted2, alertK = 50, waitTime = 0.55, treatEffect = 0)
# summary(amShifted2)
# summary(am2)


# Explore ECDF of Bias and Sample Size
ooo <- ecdf.sgpvAM(am = amShifted2, stat = "Bias",alertK = 50,treatEffect = 0,xlim = c(-1,2))
ooo <- ecdf.sgpvAM(am = amShifted2, stat = "Bias",waitWidth = 0.55,alertK = 50,treatEffect = 0,xlim = c(-1,2))
ooo <- ecdf.sgpvAM(am = amShifted2, stat = "Size",alertK = 50,treatEffect = 0,xlim = c(0,800))

# Explore quantiles of sample size for fully specified study design
# See probability of stopping by certain sample size under fully specified design
ooo <- ecdf.sgpvAM(am = amShifted2, stat = "Size",waitWidth = 0.7,alertK = 50,treatEffect = 0,xlim = c(0,400))
quantile(ooo, probs=c(0,0.05,0.1,0.2,0.5,0.8,0.9,0.95,1))
ooo(250)



```
